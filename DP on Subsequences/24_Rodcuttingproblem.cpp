/*Rod Cutting Problem
We are given a rod of size ‘N’. It can be cut into pieces.
Each length of a piece has a particular price given by the price array.
Our task is to find the maximum revenue that can be generated by selling the rod after cutting(if required) into pieces.
*/
#include <bits/stdc++.h>
using namespace std;

// same approach we try for take or no take options
// we take only if the length is less than target length remaining and not take for all other cases
// we then choose the max option out of them, making up the recurrence formula
int recursion(int i, int l, vector<int> &price)
{
    // base case
    if (i == 0)
    {
        if (l > 0)
            return price[0] * l;
        else
            return 0;
    }
    // explore possibilites
    int not_cut = 0 + recursion(i - 1, l, price);
    int cut = INT_MIN;
    int rodlength = i + 1;
    if (rodlength <= l)
        cut = price[i] + recursion(i, l - rodlength, price);
    // return
    return max(not_cut, cut);
}

int memoization(int i, int l, vector<int> &price, vector<vector<int>> &dp)
{
    // base case
    if (i == 0)
    {
        if (1 <= l)
            return price[0] * l;
        else
            return 0;
    }
    if (dp[i][l] != -1)
        return dp[i][l];
    // explore possibilites
    int not_cut = 0 + recursion(i - 1, l, price);
    int cut = INT_MIN;
    int rodlength = i + 1;
    if (rodlength <= l)
        cut = price[i] + recursion(i, l - rodlength, price);
    // return
    return dp[i][l] = max(not_cut, cut);
}

int tabulation(vector<int> &price)
{
    int n = price.size();
    vector<vector<int>> dp(n, vector<int>(n + 1, 0));
    // base case
    for (int i = 1; i < n + 1; i++)
        dp[0][i] = price[0] * i;
    // for loop iterations
    for (int i = 1; i < n; i++)
        for (int l = 0; l < n + 1; l++)
        {
            int not_cut = 0 + dp[i - 1][l];
            int cut = INT_MIN;
            int rodlength = i + 1;
            if (rodlength <= l)
                cut = price[i] + dp[i][l - rodlength];
            // return
            dp[i][l] = max(not_cut, cut);
        }
    // return statement
    return dp[n - 1][n];
}

int spaceoptimisation(vector<int> &price)
{
    int n = price.size();
    vector<int> curr(n + 1, 0);
    // base case
    for (int i = 1; i < n + 1; i++)
        curr[i] = price[0] * i;
    // for loop iterations
    for (int i = 1; i < n; i++){
        for (int l = 0; l < n + 1; l++)
        {
            int not_cut = 0 + curr[l];
            int cut = INT_MIN;
            int rodlength = i + 1;
            if (rodlength <= l)
                cut = price[i] + curr[l - rodlength];
            // return
            curr[l] = max(not_cut, cut);
        }
    }
    // return statement
    return curr[n];
}

int rodcutmaxprice(int n, vector<int> &price)
{
    // vector<vector<int>> dp(n, vector<int>(n + 1, -1));
    int ans = spaceoptimisation(price);
    return ans;
}
int main()
{

    vector<int> price = {2, 5, 7, 8, 10};
    int l = price.size();
    cout << rodcutmaxprice(l, price);
    return 0;
}